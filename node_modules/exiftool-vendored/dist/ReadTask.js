"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReadTask = exports.nullish = void 0;
const batch_cluster_1 = require("batch-cluster");
const _path = __importStar(require("path"));
const ExifDate_1 = require("./ExifDate");
const ExifDateTime_1 = require("./ExifDateTime");
const ExifTime_1 = require("./ExifTime");
const ExifToolTask_1 = require("./ExifToolTask");
const Maybe_1 = require("./Maybe");
const Number_1 = require("./Number");
const String_1 = require("./String");
const Timezones_1 = require("./Timezones");
const tzlookup = require("tz-lookup");
/**
 * tag names we don't need to muck with:
 */
const PassthroughTags = [
    "ExifToolVersion",
    "DateStampMode",
    "Sharpness",
    "Firmware",
    "DateDisplayFormat",
];
const nullishes = ["undef", "null", "undefined"];
function nullish(s) {
    return s == null || ((0, String_1.isString)(s) && nullishes.includes(s.trim()));
}
exports.nullish = nullish;
class ReadTask extends ExifToolTask_1.ExifToolTask {
    constructor(sourceFile, args) {
        super(args);
        this.sourceFile = sourceFile;
        this.args = args;
        /** May have keys that are group-prefixed */
        this._raw = {};
        /** Always has non-group-prefixed keys */
        this._tags = {};
        this.invalidLatLon = false;
        this.degroup = this.args.indexOf("-G") !== -1;
        this.tags = { SourceFile: sourceFile };
        this.tags.errors = this.errors;
    }
    static for(filename, numericTags, optionalArgs = []) {
        const sourceFile = _path.resolve(filename);
        const args = [
            "-json",
            "-struct",
            ...optionalArgs,
        ];
        // IMPORTANT: "-all" must be after numeric tag references (first reference
        // in wins)
        args.push(...numericTags.map((ea) => "-" + ea + "#"));
        // TODO: Do you need -xmp:all, -all, or -all:all?
        args.push("-all", "-charset", "filename=utf8", sourceFile);
        return new ReadTask(sourceFile, args);
    }
    toString() {
        return "ReadTask" + this.sourceFile + ")";
    }
    parse(data, err) {
        try {
            this._raw = JSON.parse(data)[0];
        }
        catch (jsonError) {
            // TODO: should restart exiftool?
            (0, batch_cluster_1.logger)().warn("ExifTool.ReadTask(): Invalid JSON", {
                data,
                err,
                jsonError,
            });
            throw err !== null && err !== void 0 ? err : jsonError;
        }
        // ExifTool does "humorous" things to paths, like flip path separators. resolve() undoes that.
        const SourceFile = _path.resolve(this._raw.SourceFile);
        // Sanity check that the result is for the file we want:
        if (SourceFile !== this.sourceFile) {
            // Throw an error rather than add an errors string because this is *really* bad:
            throw new Error(`Internal error: unexpected SourceFile of ${this._raw.SourceFile} for file ${this.sourceFile}`);
        }
        if (this.degroup) {
            Object.keys(this._raw).forEach((keyWithGroup) => {
                this._tags[this.tagName(keyWithGroup)] = this._raw[keyWithGroup];
            });
        }
        else {
            this._tags = this._raw;
        }
        return this.parseTags();
    }
    tagName(k) {
        var _a;
        return this.degroup ? (_a = k.split(":")[1]) !== null && _a !== void 0 ? _a : k : k;
    }
    parseTags() {
        this.extractLatLon();
        this.extractTzOffset();
        Object.keys(this._raw).forEach((key) => (this.tags[key] = this.parseTag(key, this._raw[key])));
        (0, Maybe_1.map)(this.tz, (ea) => (this.tags.tz = ea));
        (0, Maybe_1.map)(this.tzSource, (ea) => (this.tags.tzSource = ea));
        if (this.errors.length > 0)
            this.tags.errors = this.errors;
        return this.tags;
    }
    extractLatLon() {
        var _a, _b;
        (_a = this.lat) !== null && _a !== void 0 ? _a : (this.lat = this.latlon("GPSLatitude", "S", 90));
        (_b = this.lon) !== null && _b !== void 0 ? _b : (this.lon = this.latlon("GPSLongitude", "W", 180));
        if (this.invalidLatLon) {
            this.lat = this.lon = undefined;
        }
    }
    latlon(tagName, negateRef, maxValid) {
        const tagValue = this._tags[tagName];
        const ref = this._tags[tagName + "Ref"];
        const result = (0, Number_1.toF)(tagValue);
        if (result == null) {
            return;
        }
        else if (Math.abs(result) > maxValid) {
            this.errors.push(`Invalid ${tagName}: ${JSON.stringify(tagValue)}`);
            this.invalidLatLon = true;
            return;
        }
        else if ((0, String_1.blank)(ref)) {
            // Videos may not have a GPSLatitudeRef or GPSLongitudeRef: if this is the case, assume the given sign is correct.
            return result;
        }
        else {
            // Versions of ExifTool pre-12 returned properly-negated lat/lon. ExifTool
            // 12+ always returns positive values (!!). Also: if '-GPS*#' is set,
            // we'll see "S" instead of "South", hence the .startsWith() instead of
            // ===:
            const negative = (0, String_1.toS)(ref).toUpperCase().startsWith(negateRef);
            return (negative ? -1 : 1) * Math.abs(result);
        }
    }
    extractTzOffset() {
        (0, Maybe_1.map)((0, Maybe_1.firstDefinedThunk)([
            () => (0, Timezones_1.extractTzOffsetFromTags)(this._tags),
            () => {
                if (!this.invalidLatLon && this.lat != null && this.lon != null) {
                    try {
                        return (0, Maybe_1.map)(tzlookup(this.lat, this.lon), (tz) => ({
                            tz,
                            src: "from Lat/Lon",
                        }));
                    }
                    catch (err) {
                        /* */
                    }
                }
                return;
            },
            () => (0, Timezones_1.extractTzOffsetFromUTCOffset)(this._tags),
        ]), (ea) => ({ tz: this.tz, src: this.tzSource } = ea));
    }
    parseTag(tagNameWithGroup, value) {
        var _a, _b, _c, _d, _e, _f;
        if (nullish(value))
            return undefined;
        const tagName = this.tagName(tagNameWithGroup);
        try {
            if (PassthroughTags.indexOf(tagName) >= 0) {
                return value;
            }
            if (tagName === "GPSLatitude") {
                return this.lat;
            }
            if (tagName === "GPSLongitude") {
                return this.lon;
            }
            const tz = tagName.includes("UTC") || tagName.startsWith("GPS") ? "UTC" : this.tz;
            if (typeof value === "string" && tagName.includes("DateTime")) {
                const d = (_a = ExifDateTime_1.ExifDateTime.fromExifStrict(value, tz)) !== null && _a !== void 0 ? _a : ExifDateTime_1.ExifDateTime.fromISO(value, tz);
                if (d != null) {
                    return d;
                }
            }
            if (typeof value === "string" && tagName.includes("Date")) {
                const d = (_f = (_e = (_d = (_c = (_b = ExifDateTime_1.ExifDateTime.fromExifStrict(value, tz)) !== null && _b !== void 0 ? _b : ExifDateTime_1.ExifDateTime.fromISO(value, tz)) !== null && _c !== void 0 ? _c : ExifDateTime_1.ExifDateTime.fromExifLoose(value, tz)) !== null && _d !== void 0 ? _d : ExifDate_1.ExifDate.fromExifStrict(value)) !== null && _e !== void 0 ? _e : ExifDate_1.ExifDate.fromISO(value)) !== null && _f !== void 0 ? _f : ExifDate_1.ExifDate.fromExifLoose(value);
                if (d != null) {
                    return d;
                }
            }
            if (typeof value === "string" && tagName.includes("Time")) {
                const t = ExifTime_1.ExifTime.fromEXIF(value);
                if (t != null)
                    return t;
            }
            // Trust that ExifTool rendered the value with the correct type in JSON:
            return value;
        }
        catch (e) {
            this.addError(`Failed to parse ${tagName} with value ${JSON.stringify(value)}: ${e}`);
            return value;
        }
    }
}
exports.ReadTask = ReadTask;
//# sourceMappingURL=ReadTask.js.map