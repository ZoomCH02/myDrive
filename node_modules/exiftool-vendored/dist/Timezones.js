"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractTzOffsetFromUTCOffset = exports.inferLikelyOffsetMinutes = exports.extractTzOffsetFromTags = exports.extractOffset = exports.offsetMinutesToZoneName = exports.reasonableTzOffsetMinutes = exports.UnsetZoneName = exports.UnsetZone = exports.UnsetZoneOffsetMinutes = exports.MaxTzOffsetHours = void 0;
const luxon_1 = require("luxon");
const Array_1 = require("./Array");
const DateTime_1 = require("./DateTime");
const ExifDateTime_1 = require("./ExifDateTime");
const Maybe_1 = require("./Maybe");
const Number_1 = require("./Number");
const String_1 = require("./String");
// Pacific/Kiritimati is +14:00 TIL
// https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
exports.MaxTzOffsetHours = 14;
// Not in typings:
exports.UnsetZoneOffsetMinutes = -1;
exports.UnsetZone = luxon_1.FixedOffsetZone.instance(exports.UnsetZoneOffsetMinutes);
exports.UnsetZoneName = exports.UnsetZone.name;
function reasonableTzOffsetMinutes(tzOffsetMinutes) {
    return ((0, Number_1.isNumber)(tzOffsetMinutes) &&
        Math.abs(tzOffsetMinutes) < exports.MaxTzOffsetHours * 60);
}
exports.reasonableTzOffsetMinutes = reasonableTzOffsetMinutes;
/**
 * Returns a "zone name" (used by `luxon`) that encodes the given offset.
 */
function offsetMinutesToZoneName(offsetMinutes) {
    if (offsetMinutes == null ||
        !(0, Number_1.isNumber)(offsetMinutes) ||
        offsetMinutes === exports.UnsetZoneOffsetMinutes)
        return undefined;
    if (offsetMinutes === 0)
        return "UTC";
    const sign = offsetMinutes < 0 ? "-" : "+";
    const absMinutes = Math.abs(offsetMinutes);
    if (absMinutes > exports.MaxTzOffsetHours * 60)
        return undefined;
    const hours = Math.floor(absMinutes / 60);
    const minutes = Math.abs(absMinutes % 60);
    return (`UTC${sign}` +
        (minutes === 0 ? `${(0, String_1.pad2)(hours)}` : `${(0, String_1.pad2)(hours)}:${(0, String_1.pad2)(minutes)}`));
}
exports.offsetMinutesToZoneName = offsetMinutesToZoneName;
function dtToMs(s, defaultZone) {
    return (0, Maybe_1.map)(ExifDateTime_1.ExifDateTime.fromExifStrict(s, defaultZone), (dt) => dt.toDate().getTime());
}
function utcToMs(s) {
    return dtToMs(s, "UTC");
}
function tzHourToOffset(n) {
    return (0, Number_1.isNumber)(n) && reasonableTzOffsetMinutes(n * 60)
        ? offsetMinutesToZoneName(n * 60)
        : undefined;
}
const tzRe = /(?:UTC)?([+-]?)(\d\d?)(?::(\d\d))?/;
/**
 * Parse a timezone offset and return the offset minutes
 */
function extractOffset(tz) {
    if (tz == null || (0, String_1.blank)(tz)) {
        return undefined;
    }
    if ((0, String_1.isString)(tz) && luxon_1.Info.isValidIANAZone(tz)) {
        return { tz, src: "validIANAZone" };
    }
    return (0, Maybe_1.map)(tzRe.exec(tz), (m) => {
        var _a;
        return (0, Maybe_1.map)(offsetMinutesToZoneName((m[1] === "-" ? -1 : 1) *
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            (parseInt(m[2]) * 60 + parseInt((_a = m[3]) !== null && _a !== void 0 ? _a : "0"))), (ea) => ({ tz: ea, src: "offsetMinutesToZoneName" }));
    });
}
exports.extractOffset = extractOffset;
function extractTzOffsetFromTags(t) {
    return (0, Maybe_1.firstDefinedThunk)([
        () => (0, Maybe_1.first)([
            "TimeZone",
            "OffsetTime",
            "OffsetTimeOriginal",
            "OffsetTimeDigitized",
            "TimeZoneOffset",
        ], (tagName) => (0, Maybe_1.map)(extractOffset(t[tagName]), (ea) => ({
            tz: ea.tz,
            src: ea.src + " from " + tagName,
        }))),
        () => (0, Maybe_1.map)(t.TimeZoneOffset, (value) => (0, Maybe_1.map)(tzHourToOffset(Array.isArray(value) ? value[0] : value), (tz) => ({
            tz,
            src: "TimeZoneOffset",
        }))),
    ]);
}
exports.extractTzOffsetFromTags = extractTzOffsetFromTags;
function firstUtcMs(tags, tagNames) {
    return (0, Maybe_1.first)(tagNames, (tagName) => (0, Maybe_1.map)(utcToMs(tags[tagName]), (utcMs) => ({ tagName, utcMs })));
}
// timezone offsets may be on a 15 minute boundary, but if GPS acquisition is
// old, this can be spurious. We get less mistakes with a larger multiple, so
// we're using 30 minutes instead of 15. See
// https://www.timeanddate.com/time/time-zones-interesting.html
const TzBoundaryMinutes = 30;
function inferLikelyOffsetMinutes(deltaMs) {
    return TzBoundaryMinutes * Math.floor(deltaMs / DateTime_1.MinuteMs / TzBoundaryMinutes);
}
exports.inferLikelyOffsetMinutes = inferLikelyOffsetMinutes;
function extractTzOffsetFromUTCOffset(t) {
    const gpsStamps = (0, Array_1.compact)([t.GPSDateStamp, t.GPSTimeStamp]);
    const GPSDateTimeStamp = gpsStamps.length === 2 ? gpsStamps.join(" ") : undefined;
    const utc = firstUtcMs({ ...t, GPSDateTimeStamp }, [
        "GPSDateTime",
        "DateTimeUTC",
        "GPSDateTimeStamp",
    ]);
    const dt = firstUtcMs(t, [
        "SubSecDateTimeOriginal",
        "DateTimeOriginal",
        "SubSecCreateDate",
        "CreateDate",
        "SubSecMediaCreateDate",
        "MediaCreateDate",
        "DateTimeCreated",
    ]);
    if (utc == null || dt == null)
        return;
    // By flooring
    const offsetMinutes = inferLikelyOffsetMinutes(dt.utcMs - utc.utcMs);
    return (0, Maybe_1.map)(offsetMinutesToZoneName(offsetMinutes), (tz) => ({
        tz,
        src: `offset between ${dt.tagName} and ${utc.tagName}`,
    }));
}
exports.extractTzOffsetFromUTCOffset = extractTzOffsetFromUTCOffset;
//# sourceMappingURL=Timezones.js.map