"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExifDateTime = void 0;
const luxon_1 = require("luxon");
const DateTime_1 = require("./DateTime");
const Maybe_1 = require("./Maybe");
const String_1 = require("./String");
const Timezones_1 = require("./Timezones");
/**
 * Encodes an ExifDateTime with an optional tz offset in minutes.
 */
class ExifDateTime {
    constructor(year, month, day, hour, minute, second, millisecond, tzoffsetMinutes, rawValue, zoneName) {
        this.year = year;
        this.month = month;
        this.day = day;
        this.hour = hour;
        this.minute = minute;
        this.second = second;
        this.millisecond = millisecond;
        this.tzoffsetMinutes = tzoffsetMinutes;
        this.rawValue = rawValue;
        this.zoneName = zoneName;
    }
    static fromISO(iso, zone, rawValue) {
        if ((0, String_1.blank)(iso) || null != iso.match(/^\d+$/))
            return undefined;
        return this.fromDateTime(luxon_1.DateTime.fromISO(iso, {
            setZone: true,
            zone: zone !== null && zone !== void 0 ? zone : Timezones_1.UnsetZone,
        }), rawValue !== null && rawValue !== void 0 ? rawValue : iso);
    }
    /**
     * Try to parse a date-time string from EXIF. If there is not both a date and
     * a time component, returns `undefined`.
     *
     * @param text from EXIF metadata
     * @param defaultZone a "zone name" which may be IANA, like
     * "America/Los_Angeles", or an offset, like "UTC-3". See
     * `offsetMinutesToZoneName`.
     */
    static fromEXIF(text, defaultZone) {
        if ((0, String_1.blank)(text))
            return undefined;
        return (0, Maybe_1.firstDefinedThunk)([
            () => this.fromExifStrict(text, defaultZone),
            () => this.fromISO(text, defaultZone),
            () => this.fromExifLoose(text, defaultZone),
        ]);
    }
    static fromPatterns(text, fmts) {
        const s = (0, String_1.toS)(text).trim();
        const inputs = [s];
        // Some EXIF datetime will "over-specify" and include both the utc offset
        // *and* the "time zone abbreviation", like PST or PDT.
        // TZAs are between 2 (AT) and 5 (WEST) characters.
        // Unfortunately, luxon doesn't support regex.
        // We only want to strip off the TZA if it isn't "UTC" or "Z"
        if (null == s.match(/[.\d\s](utc|z)$/i)) {
            const noTza = s.replace(/ [a-z]{2,5}$/i, "");
            if (noTza !== s)
                inputs.push(noTza);
        }
        return (0, Maybe_1.first)(inputs, (input) => (0, Maybe_1.first)(fmts, ({ fmt, zone }) => (0, Maybe_1.map)(luxon_1.DateTime.fromFormat(input, fmt, {
            setZone: true,
            zone: zone !== null && zone !== void 0 ? zone : Timezones_1.UnsetZone,
        }), (dt) => this.fromDateTime(dt, s))));
    }
    static fromExifStrict(text, zone) {
        if ((0, String_1.blank)(text))
            return undefined;
        return this.fromPatterns(text, [
            // if it specifies a zone, use it:
            { fmt: "y:M:d H:m:s.uZZ" },
            { fmt: "y:M:d H:m:sZZ" },
            // if it specifies UTC, use it:
            { fmt: "y:M:d H:m:s.u'Z'", zone: "utc" },
            { fmt: "y:M:d H:m:s'Z'", zone: "utc" },
            // Otherwise use the default zone:
            { fmt: "y:M:d H:m:s.u", zone },
            { fmt: "y:M:d H:m:s", zone },
            // Not found yet? Maybe it's in ISO format? See https://github.com/photostructure/exiftool-vendored.js/issues/71
            // if it specifies a zone, use it:
            { fmt: "y-M-d'T'H:m:s.uZZ" },
            { fmt: "y-M-d'T'H:m:sZZ" },
            // if it specifies UTC, use it:
            { fmt: "y-M-d'T'H:m:s.u'Z'", zone: "utc" },
            { fmt: "y-M-d'T'H:m:s'Z'", zone: "utc" },
            // Otherwise use the default zone:
            { fmt: "y-M-d'T'H:m:s.u", zone },
            { fmt: "y-M-d'T'H:m:s", zone },
        ]);
    }
    static fromExifLoose(text, defaultZone) {
        if ((0, String_1.blank)(text))
            return undefined;
        const zone = (0, String_1.notBlank)(defaultZone) ? defaultZone : Timezones_1.UnsetZone;
        return this.fromPatterns(text, [
            // FWIW, the following are from actual datestamps seen in the wild:
            { fmt: "MMM d y H:m:sZZZ" },
            { fmt: "MMM d y H:m:s", zone },
            { fmt: "MMM d y, H:m:sZZZ" },
            { fmt: "MMM d y, H:m:s", zone },
            // Thu Oct 13 00:12:27 2016:
            { fmt: "ccc MMM d H:m:s yZZ" },
            { fmt: "ccc MMM d H:m:s y", zone },
        ]);
    }
    static fromDateTime(dt, rawValue) {
        var _a;
        if (dt == null ||
            !dt.isValid ||
            dt.toMillis() === 0 ||
            dt.year === 0 ||
            dt.year === 1) {
            return undefined;
        }
        return new ExifDateTime(dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second, dt.millisecond, dt.offset === Timezones_1.UnsetZoneOffsetMinutes ? undefined : dt.offset, rawValue, ((_a = dt.zone) === null || _a === void 0 ? void 0 : _a.name) === Timezones_1.UnsetZone.name ? undefined : dt.zoneName);
    }
    get millis() {
        return this.millisecond;
    }
    get hasZone() {
        return (0, String_1.notBlank)(this.zone);
    }
    get zone() {
        var _a;
        return (_a = this.zoneName) !== null && _a !== void 0 ? _a : (0, Timezones_1.offsetMinutesToZoneName)(this.tzoffsetMinutes);
    }
    toDateTime() {
        return luxon_1.DateTime.fromObject({
            year: this.year,
            month: this.month,
            day: this.day,
            hour: this.hour,
            minute: this.minute,
            second: this.second,
            millisecond: this.millisecond,
        }, {
            zone: this.zone,
        });
    }
    toDate() {
        return this.toDateTime().toJSDate();
    }
    toISOString(options = {}) {
        var _a;
        return (0, Maybe_1.denull)(this.toDateTime().toISO({
            suppressMilliseconds: (_a = options.suppressMilliseconds) !== null && _a !== void 0 ? _a : this.millisecond == null,
            includeOffset: this.hasZone && options.includeOffset !== false,
        }));
    }
    toExifString() {
        return (0, DateTime_1.dateTimeToExif)(this.toDateTime());
    }
    toString() {
        return this.toISOString();
    }
    get isValid() {
        return this.toDateTime().isValid;
    }
    toJSON() {
        return {
            _ctor: "ExifDateTime",
            year: this.year,
            month: this.month,
            day: this.day,
            hour: this.hour,
            minute: this.minute,
            second: this.second,
            millisecond: this.millisecond,
            tzoffsetMinutes: this.tzoffsetMinutes,
            rawValue: this.rawValue,
            zoneName: this.zoneName,
        };
    }
    static fromJSON(json) {
        return new ExifDateTime(json.year, json.month, json.day, json.hour, json.minute, json.second, json.millisecond, json.tzoffsetMinutes, json.rawValue, json.zoneName);
    }
}
exports.ExifDateTime = ExifDateTime;
//# sourceMappingURL=ExifDateTime.js.map